# Update Slack Workflow Canvas Action

This action creates or updates a workflow status, 
and outputs the status canvas so that it can be 
carried throughout an entire Actions workflow.

![Example slack output created by this action](example-screenshot.png)


### Style using mrkdwn

No, not markdown, mrkdwn. This is a Slack thing. It's limited, but functional.

### One message per workflow execution

The action maintains the state of a single message (referred to herein as a 
canvas) throughout the workflow execution, then "freezes" it when your workflow is 
finalized. If the workflow is re-run, a new message will appear in the designated 
channel.

### Iconography for at-a-glance statuses:

This uses some (not cute or animated) emoji to add some iconography for the various 
states of a step. All workflows using this action will have the same iconography and 
steps, which makes the tool more helpful for everyone. 


### Standalone app can be used however you like

You don't have to use actions to use the app! You can use the docker container and 
bring your own bot token. (Docker container currently requires access to the IAM gcr 
repository; if there is external interest I am happy to wire this up to Github as well.)


### Safe for parallel jobs

It is possible to use this action in jobs that run in parallel. This action comes
with a locking mechanism so that only one job can "check out" the workflow canvas at
a time to update it.

### Flexible use cases

You can define your entire workflow at the beginning, or add steps ad-hoc as your 
workflow progresses. Updates are atomic within the context of a given workflow 

For available commands, see [commands](#command).

## Inputs

(alphabetical)

### `canvas-id`
**REQUIRED**. This must be a pseudo-unique identifier that links your change to the 
running workflows. If not provided, it will be randomly generated and output from 
the `create-canvas` command.

The id only needs to be
unique within the scope of the time that workflow is running; it's ok if the id is
repeated on future runs. A safe bet is `${{ github.run_id }}.${{ github.run_number }}`.

### `channel`
**REQUIRED** if command is `create-canvas`**, otherwise ignored. Sets the
channel for the workflow canvas. 

If you want to send messages to more than one channel per workflow, you need to 
maintain more than one canvas.

### `command`
**Required** One of the available action commands:

- `create-canvas`
  - Creates a workflow canvas to be used throughout your workflow.
    This canvas is deterministic, so can safely be stored and later re-used
    at any time.
- `create-step`
  - Adds a step to workflow canvas. A step must be added in order for its state
    to be updateable. 
- `update-workflow`
  - Updates the status of the workflow and/or one of its steps.
- `add-artifact`
  - Adds static `mrkdwn` text as a context block element to the bottom of the canvas.
    A maximum of 9 artifacts is supported; more than that will throw an error. 
    Artifacts will be presented as tiny code-block tags at the bottom of the 
    workflow canvas. Once added, an artifact cannot be removed or changed.
- `finalize-workflow` marks the workflow as COMPLETED (regardless of other status) 
  and deletes the datastore records used to maintain the canvas. The slack message 
  will no longer be editable, and its output will be frozen. Please ensure this is 
  always called at the end of your workflow to avoid storing unnecessary data. Any 
  data in the `github-actions` namespace of our Datastore is subject to removal at 
  any time.
  
### `description`
**Required** if command is `add-artifact`, `create-workflow`.
**Optional** if command is `create-step`, `update-workflow`.

If the command is `create-workflow`, the description may only include plain text.
All other uses allow Slack's proprietary `mrkdwn` syntax.


### `step-id`
**Optional** if command is `create-step`, `update-workflow`, otherwise _ignored_.
This needs to be unique within your workflow. If not provided during `create-step`, 
one will be autogenerated and output from the `create-step` command as `step-id`.

### `step-status`

**Optional**, if the command is `create-step` or `update-workflow`.

Defaults to `not started`.

Must be one of the following strings:

- not started
- in progress
- skipped
- succeeded
- failed

### `workflow-status`

**Optional** if the command is `create-workflow`, `create-step`, `update-workflow`, 
`add-artifact`, `finalize-workflow`. 

Any of the following strings:

- initializing
- in progress
- succeeded
- failed

NB: Because the Slack messaging is part of the workflow, the workflow itself is 
never in a state of 'not started,' therefore defaulting to 'initializing'.


## Outputs

(alphabetical)

### `canvas-id`

From `create-workflow`

The pseudo-unique id of the Slack "canvas" used to track the workflow status. This is 
used to look up and update the message in later steps. 

### `fingerprint`

From _all commands_: The SHA256 fingerprint of the code behind the action; this can
be used for debugging or version validation. (This is calculated using the actions
`hashFiles` function.)

### `step-id`

From `create-step`

The unique id of the step just created. If not explicitly provided, this output must be
used to update the workflow step.


## Example Use

The following is an annotated example that demonstrates this action's features and 
how you might want to apply them.

```yaml
env:
  # This environment variable supplies the id to all uses without you having
  # to think about it.
  SLACK_CANVAS_ID: ${{ github.run_id }}.${{ github.run_number }}
  # Always required; this secret is available to all UWIT-IAM repositories.
  SLACK_BOT_TOKEN: ${{ secrets.ACTIONS_SLACK_BOT_TOKEN }}
steps:
  # The create-canvas command creates a skeleton of the message in slack,
  # initializes references, and creates a SLACK_WORKFLOW_CONTEXT environment variable
  # that is accessible in all future steps.
  # The environment variable can also be referenced as the 'canvas' output:
  - uses: UWIT-IAM/actions/update-slack-workflow-canvas
    id: initial-workflow-step   # Optional, if you want to use the 'outputs' context
    with:
      command: create-canvas
      description: "Dev release workflow"
  # The initialize-step command adds a step to an existing workflow.
  - uses: UWIT-IAM/actions/update-slack-workflow-canvas
    with:
      command: create-step
      step-id: build-images
  # The update-workflow step will update the status of the workflow and/or any 
  # step (by id).
  - uses: UWIT-IAM/actions/update-slack-workflow-canvas
    with:
      command: update-workflow
      workflow-status: in progress
      step-status: in progress
      step-id: build-images
      # An alternative way to provide the canvas, if you don't want to use the
      # environment variable
      canvas-id: ${{ steps.create-canvas.outputs.canvas-id }}
  - run: docker build -t my-image .
    id: build-image
  # If the previous step (docker build . . .) fails, update the step status to 
  # reflect that.
  - if: failure()
    uses: UWIT-IAM/actions/update-slack-workflow-canvas
    step-status: failed
    step-id: build-images
  # Otherewise, we continue as normal.
  # Perhaps our `build-image` step also runs tests which generate a coverage report.
  # We can attach the report to our canvas like this. 
  - uses: UWIT-IAM/actions/update-slack-workflow-canvas
    with:
      command: add-artifact
      description: >
        Coverage: 
        <${{ steps.build-image.outputs.coverage-report-url }}
        | ${{ steps.build-image.outputs.coverage-percent }}>
  # . . . update the status to reflect success
  - uses: UWIT-IAM/actions/update-slack-workflow-canvas
    with:
      command: update-workflow
      step-status: succeeded
      step-id: build-images
  # At the end of your workflow, if everything succeeds,
  # update the workflow status
  - uses: UWIT-IAM/actions/update-slack-workflow-canvas
    with:
      command: update-workflow
      workflow-status: succeeded
  - uses: UWIT-IAM/actions/update-slack-workflow-canvas
    if: failure()
    with:
      command: update-workflow
      workflow-status: failed
  # Always clean up at the end of the workflow to avoid
  # storing unnecessary data. This "freezes" the message.
  - uses: UWIT-IAM/actions/update-slack-workfklow-canvas
    if: always()
    with:
      command: finalize-workflow
```

## Development

### To-dos

- Template support
  - Support defining templates within a repository that can be provided to workflows,
    so that the default state can be provided instead of having to define every step 
    inside the Action.
    

### Action architecture

- The action app, `/action/*.py` (the python code) is responsible for 
  the business logic.. It is mostly decoupled from the other interfaces, 
  except for that it does print Github 
  Actions commands itself (`set-output`, for example). This means that it can run
  independently of the action for testing and development, and that you will see 
  the output that github itself consumes when the code runs inside an action.
- The `entrypoint.sh` script, serves as the [Docker](Dockerfile) entrypoint; 
  by building and running the [Dockerfile](Dockerfile) image, you are executing this 
  script. This script takes no arguments, and requires environment variables be set.
  This is by design. (See below.)
- The `action.yml` is how github consumes the action configuration, and is also used 
  as a reference artifact for people who want to use this action. 
- The `run-from-env.sh` script is a way to run the action _as if you were executing 
  an Actions workflow_. This is also how the action is able to test itself before 
  deploying to the docker repository. To do this yourself, you need a copy of the 
  slack bot api token. For now, just ask Tom if you need this.
  
> Why is the entrypoint environment-variable driven?

I chose this design because it allows a unified interface that allows the action to 
be run the same way for both consuming workflows and developers who want to test 
this action, as well as for Github Actions to test this action itself.

The `action.yml` is really only responsible for setting environment variables; it 
loads directly into a pre-built docker container and simply runs the `entrypoint.sh` 
which is responsible for translating the environment variables into command-line 
arguments.

This results in a modular set up that allows multiple different commands to be run 
the same way for everyone, and using the same action interface. 

Lastly, the application code is sufficiently decoupled from the running context that 
either could be factored somewhere else with ease. The action only knows about its 
runtime image; the image entrypoint only knows how to translate the request to one 
the app can read; the app can be run and tested by humans, and scaled independently 
of the interface to Actions.

If you don't like it, you can always run with the entrypoint `python run.py` instead,
and then use CLI args instead of environment variables.
